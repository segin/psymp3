#include <iostream>
#include <iomanip>
#include <cstdint>

int main() {
    // Reproduce the test data generation logic
    uint32_t sr_ch_bps = (44100 << 12) | (1 << 9) | (15); // From the test
    
    std::cout << "sr_ch_bps = 0x" << std::hex << sr_ch_bps << std::dec << std::endl;
    
    uint8_t byte1 = (sr_ch_bps >> 16) & 0xFF;
    uint8_t byte2 = (sr_ch_bps >> 8) & 0xFF;
    uint8_t byte3 = sr_ch_bps & 0xFF;
    
    std::cout << "Generated bytes: 0x" << std::hex << std::setw(2) << std::setfill('0') 
              << static_cast<int>(byte1) << " 0x" << static_cast<int>(byte2) 
              << " 0x" << static_cast<int>(byte3) << std::dec << std::endl;
    
    // This should match the failing test data: 0xc4 0x42 0x0f
    
    // Now let's see what the correct packing should be for 44100 Hz, 2 channels, 16 bits
    std::cout << "\nCorrect packing for 44100 Hz, 2 channels, 16 bits:" << std::endl;
    
    // According to FLAC spec:
    // Sample rate: 20 bits = 44100
    // Channels: 3 bits = 2-1 = 1  
    // Bits per sample: 5 bits = 16-1 = 15
    // Total samples high: 4 bits = 0 (we'll use 0 for now)
    
    uint32_t correct_packed = (44100 << 12) | ((2-1) << 9) | ((16-1) << 4) | 0;
    std::cout << "Correct packed = 0x" << std::hex << correct_packed << std::dec << std::endl;
    
    uint8_t correct_byte1 = (correct_packed >> 24) & 0xFF;
    uint8_t correct_byte2 = (correct_packed >> 16) & 0xFF;
    uint8_t correct_byte3 = (correct_packed >> 8) & 0xFF;
    uint8_t correct_byte4 = correct_packed & 0xFF;
    
    std::cout << "Correct bytes: 0x" << std::hex << std::setw(2) << std::setfill('0') 
              << static_cast<int>(correct_byte1) << " 0x" << static_cast<int>(correct_byte2) 
              << " 0x" << static_cast<int>(correct_byte3) << " 0x" << static_cast<int>(correct_byte4) 
              << std::dec << std::endl;
    
    return 0;
}